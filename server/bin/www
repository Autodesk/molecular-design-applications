#!/usr/bin/env node

/**
 * Module dependencies.
 */

if (!('toJSON' in Error.prototype))
  Object.defineProperty(Error.prototype, 'toJSON', {
    value: function () {
    var alt = {};

    Object.getOwnPropertyNames(this).forEach(function (key) {
      alt[key] = this[key];
    }, this);

    return alt;
  },
  configurable: true,
  writable: true
});

require('dotenv').config();
require('babel-polyfill');
const bunyan = require('bunyan');
const bunyanFormat = require('bunyan-format');

const streams = [
  {
    level: bunyan.DEBUG,
    stream: bunyanFormat({ outputMode: 'short' }),
  },
];
global.log = bunyan.createLogger({
  name: 'mdt',
  level: bunyan.TRACE,
  streams,
});

const app = require('../main/server');
const debug = require('debug')('express:server');
const http = require('http');

/**
 * Get port from environment and store in Express.
 */

var port = normalizePort(process.env.PORT || '4000');
app.set('port', port);
process.env.PORT = port;

/**
  Before we create the server, we'll populate the database
  with workflows
*/
init()
  .then((resolve, reject) => {
    /**
     * Create HTTP server.
     */
    var server = http.createServer(app);

    /**
     * Listen on provided port, on all network interfaces.
     */
    server.listen(port);
    server.on('error', onError);
    server.on('listening', onListening(server.address()));
  });

/**
 * Normalize a port into a number, string, or false.
 */

function normalizePort(val) {
  var port = parseInt(val, 10);

  if (isNaN(port)) {
    // named pipe
    return val;
  }

  if (port >= 0) {
    // port number
    return port;
  }

  return false;
}

/**
 * Event listener for HTTP server "error" event.
 */

function onError(error) {
  if (error.syscall !== 'listen') {
    throw error;
  }

  var bind = typeof port === 'string'
    ? 'Pipe ' + port
    : 'Port ' + port;

  // handle specific listen errors with friendly messages
  switch (error.code) {
    case 'EACCES':
      log.error(bind + ' requires elevated privileges');
      process.exit(1);
      break;
    case 'EADDRINUSE':
      log.error(bind + ' is already in use');
      process.exit(1);
      break;
    default:
      throw error;
  }
}

/**
 * Event listener for HTTP server "listening" event.
 */

function onListening(addr) {
  return () => {
    var bind = typeof addr === 'string'
      ? 'pipe ' + addr
      : 'port ' + addr.port;
    log.debug('Listening on ' + bind);
    var test_utils = require('../test/test_utils');
    //Wait a bit, sometimes docker takes a while
    setTimeout(() => {
      test_utils.runAllTests()
        .catch(err => {
          log.error({status:'Test failed:', error:JSON.stringify(err)});
        });
    }, 1000);
  }
}

/**
 * Event listener for HTTP server "listening" event.
 */

function init() {
    const redis = require('../utils/redis');
    const dbConstants = require('../constants/db_constants');
    return redis.hset(dbConstants.REDIS_WORKFLOWS, '0', JSON.stringify({ id: '0', title: 'VDE' }));
}

/**
 * Proxy requests to port 9000 to the CCC server
 */
const httpProxy = require('http-proxy');
httpProxy.createProxyServer({target:'http://ccc:9000'}).listen(9000);

