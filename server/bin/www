#!/usr/bin/env node

/**
 * Module dependencies.
 */
require('dotenv').config();
require('babel-polyfill');
require('debug')('express:server');
const http = require('http');
const httpProxy = require('http-proxy');
const retry = require('bluebird-retry');
const app = require('../main/server');
const dbConstants = require('../constants/db_constants');
const dbUtils = require('../utils/db_utils');
const errorUtils = require('../utils/error_utils');
const log = require('../utils/log');
const fluentSender = require('../utils/fluent_sender');
const redis = require('../utils/redis');
const seedData = require('../utils/seed_data');
const testUtils = require('../test/test_utils');

/**
 * Normalize a port into a number, string, or false.
 */
function normalizePort(val) {
  const port = parseInt(val, 10);

  if (isNaN(port)) {
    // named pipe
    return val;
  }

  if (port >= 0) {
    // port number
    return port;
  }

  return false;
}

/**
 * Get port from environment and store in Express.
 */
const port = normalizePort(process.env.PORT || '4000');
app.set('port', port);
process.env.PORT = port;

/**
 * Event listener for HTTP server 'error' event.
 */
function onError(error) {
  if (error.syscall !== 'listen') {
    throw error;
  }

  const bind = typeof port === 'string'
    ? `Pipe ${port}`
    : `Port ${port}`;

  // handle specific listen errors with friendly messages
  switch (error.code) {
    case 'EACCES':
      log.error(`${bind} requires elevated privileges`);
      process.exit(1);
      break;
    case 'EADDRINUSE':
      log.error(`${bind} is already in use`);
      process.exit(1);
      break;
    default:
      throw error;
  }
}

/**
 * Event listener for HTTP server 'listening' event.
 */
function onListening(addr) {
  return () => {
    const bind = typeof addr === 'string'
      ? `pipe ${addr}`
      : `port ${addr.port}`;
    log.debug(`Listening on ${bind}`);
    // Wait a bit, sometimes docker takes a while
    retry(
      () => testUtils.runTestCCC(),
      { max_tries: 20, interval: 1000 }
    ).then((status) => {
      log.info({ message: 'Test CCC connection', success: status.success });
    }).catch((err) => {
      log.error({ status: 'Test failed:', error: JSON.stringify(err) });
    });
  };
}

/**
  Before we create the server, we'll populate the database
  with workflows
*/
Promise.all(seedData.map(workflow =>
  dbUtils.seed(redis, dbConstants.REDIS_WORKFLOWS, workflow)
)).then(() => {
  /**
   * Create HTTP server.
   */
  const server = http.createServer(app);

  /**
   * Listen on provided port, on all network interfaces.
   */
  server.listen(port);
  server.on('error', onError);
  server.on('listening', onListening(server.address()));
  server.timeout = 8 * 60 * 1000; // 8 minutes
}).catch((err) => {
  log.error({ error: err });
});

/**
 * Proxy requests to port 9000 to the CCC server
 */
if (process.env.CCC === 'ccc:9000') {
  httpProxy.createProxyServer({ target: 'http://ccc:9000' }).listen(9000);
}

/**
 * Crash handler
 */
process.on('uncaughtException', (err) => {
  let stack = null;
  try {
    stack = err.stack;
  } catch (e) {
    console.error(e);
  }

  // You can't pass the error object directly, fluent doesn't like it.
  let errorJson = null;
  try {
    errorJson = errorUtils.toJson(err.toJSON());
  } catch (e) {
    console.error(e);
  }

  let errorString = null;
  try {
    errorString = err.toString();
  } catch (e) {
    console.error(e);
  }

  const errObj = {
    stack,
    errorJson,
    errorString,
    message: 'crash',
  };
  console.error(JSON.stringify(errObj, null, ''));
  // Ensure crash is logged to fluent before exiting.
  try {
    fluentSender.emit('mst', errObj, null, () => {
      process.exit(1);
    });
  } catch (e) {
    process.exit(1);
  }
});
